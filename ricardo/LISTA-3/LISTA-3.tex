\documentclass[a4paper,10pt,twocolumn]{article}

\usepackage{ucs}
\usepackage[latin1]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{bookman}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{indentfirst}
\usepackage{anysize}
\usepackage{xcolor}
\usepackage{listings}

\lstset{language=Haskell,
        frame=trBL,
        frameround=fttt,
        basicstyle=\small\ttfamily,
        backgroundcolor=\color{gray!30}}

\author{Universidade Federal do Ceará\\
        Campus de Quixadá\\
        Ciência da Computação\\
        Programação Funcional\\
        Prof.$^o$ Ricardo Reis}
\title{Lista de Exercícios III}
\date{\today}

\marginsize{1cm}{1cm}{1cm}{1cm}

\begin{document}

\maketitle

\noindent\textit{Construa e teste modelos de dados em Haskell que modelem os tipos de dados a seguir,} 

\begin{enumerate}
\item \textsc{Complex}: Representa números complexos e seus respectivos operadores aritméticos \\
Especificação,
\begin{lstlisting}
data Complex = Complex { real :: Float
                       , img  :: Float
                       }
instance Num Complex
instance Eq Complex
instance Fractional Complex
instance Show Complex
\end{lstlisting}
Exemplo de saída: \texttt{5.0 + 6.2j}\\
      
\item \textsc{Stack}: Representa uma pilha genérica e seus operadores fundamentais.\\
Especificação,
\begin{lstlisting}
data Stack a = Empty | Top a (Stack a) 

push :: a -> Stack a -> Stack a
pop :: Stack a -> Stack a
height :: Stack a -> Int
top:: Stack a -> Maybe a 
isEmpty:: Stack a -> Bool 

instance Show Stack
\end{lstlisting}
Exemplo de saída: \verb|Pilha de altura 5 e topo 12|

\item \textsc{Queue}: representa uma fila genérica e seus operadores fundamentais.\\
Especificação,
\begin{lstlisting}
data Queue a = Empty | Start a (Queue a)

startQueue :: Queue a -> Maybe a
endQueue :: Queue a -> Maybe a 
pushQueue :: a -> Queue a -> Queue a 
popQueue :: Queue a -> Queue a 
isEmptyQueue :: Queue a -> Bool
lenQueue :: Queue a -> Int

-- Enquanto uma dada ila de entrada 
-- não for vazia então o elemento
-- inicial (startQueue) é removido e 
-- processado por uma função de entrada. 
-- A saída é a lista dos valores obtidos
whileNotEmpty :: (a -> b) -> Queue a -> [b]  

instance Show Queue
\end{lstlisting}

\item \textsc{Matrix}: representa uma matriz numérica e algumas de suas operações fundamentais.\\
Especificação,
\begin{lstlisting}
type Row = [Float]
data Matrix = Matrix { ncols :: Int
                     , nrows :: Int
                     , rows  :: [Row]
                     }

-- matriz de zeros
zeroMatrix :: Int -> Int -> Matrix
-- matriz de uns
oneMatrix :: Int -> Int -> Matrix
-- matriz identidade : recebe ordem
identMatrix :: Int -> Matrix
-- soma duas matrizes
sumMatrix :: Matrix -> Matrix -> Matrix
-- produto de escalar por matriz
prodScalar :: Float -> Matrix -> Matrix
-- produto entre matrizes
prodMatrix :: Matrix -> Matrix -> Matrix
-- transforma listas de listas de 
-- floats numa matriz
listToMatrix :: [Row] -> Matrix

instance Show Matrix
\end{lstlisting}

\item \textsc{Date}: representa uma data com campos de dia, mês e ano. A especificação seguinte é incompleta.
Especificação,
\begin{lstlisting}
data Day = ...
data Month = ...
data Year = ...
data Date = ...

-- 'Date' deve ser instância de
-- Eq, Ord e Show
-- 'Month' deve instância de 
-- Eq, Ord, Show, Enum, Bounded

sortListDates :: [Date] -> [Date]
\end{lstlisting}
Exemplo de saída de \texttt{date}:\\
\texttt{5 de Janeiro de 2014}

\item \textsc{Pessoa}: representa uma pessoa trazendo informações de nome, idade e salário\\
Especificação,
\begin{lstlisting}
data Pessoa = { nome :: String
              , idade :: Int
              , salario :: Float }

data Criterio = ByNome | ByIdade | BySalario

-- classifica lista de pessoa por critério
sortListPessoa :: [Pessoa] 
               -> Criterio 
               -> [Pessoa]

instance Show Pessoa
\end{lstlisting}

\item \textsc{OList}: representa uma lista ligada ordenada, ou seja, uma lista que mantém suas chaves ordenadas durante seu ciclo de vida se requerer a funções de ordenação.\\
Especificação,
\begin{lstlisting}
data OList a = Empty | Node a (OList a)

-- insere em lista ordenada
infixr 5 >>>
(>>>) :: (Ord a) => a -> OList a -> OList a 

-- indica se chave está ou não numa lista
hasKey :: (Ord a) => a -> OList a -> Bool

-- remove chave de lista ordenada
remKey :: (Ord a) => a -> OList a -> OList a

-- identifica n-ésima chave de lista ordenada
key :: Int -> OList a -> Maybe a

instance Show OList
\end{lstlisting}

\end{enumerate}

\end{document}